\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
\begin{lstlisting}[language=python]
import spacy 
import random 
from spacy.util import minibatch,compounding 
from pathlib import Path 
from spacy import displacy 
import re 
from spacy.gold import GoldParse
from spacy.scorer import Scorer
from pathlib import Path

nlp=spacy.load('en_core_web_sm')
ner=nlp.get_pipe("ner")
for _,annotations in train:
    for ent in annotations.get("entities"):
        ner.add_label(ent[2])
        
disable_pipes=[pipe for pipe in nlp.pipe_names if pipe !='ner']
#training the model#
def training(train,interation,nlp):
    
    with nlp.disable_pipes(*disable_pipes):
        optimizer=nlp.begin_training()
        for iteration in range(100):
            random.shuffle(train)
            losses={}
            batches=minibatch(train,size=compounding(1.0 ,4.0 ,1.001))
            for batch in batches:
                texts,annotations=zip(*batch)
                nlp.update(
                            texts,
                            annotations,
                            drop=0.2,
                            losses=losses,
                            sgd=optimizer)
                print("losses",losses)
#reformulates input text#
def reformulate(text):
    
    pattern1=re.compile('F\([a-z]\)=.*?(?=,)')
    pattern2=re.compile('F\([a-z],t\)=F\([a-z]\).*?(?= )')

    match=[re.search(pattern,text).group() for pattern in [pattern1,pattern2] if re.search(pattern,text) is not None]
    #match[0]
    if 'temprature' in text:      #the problem is of parabolic type 
        DFE='du/dt-a*a*d(du/dt)'
        if 'heat source' or "Newton's law" or "Fourier's law"  not in text: #equation is homogenous
            print("diffential equation: "+'du/dt=a*a*d(du/dt)/dt')
        else:
            DFE='non-homogenous' 
        
    elif 'vibration' in text:      #problem type of hyperbolic type
        DF='hyperbolic'
        if 'force' or 'excitaion' not in text:    #problem is homogenous
            print("diffential equation: "+'du/dt=a*a*d(du/dt)/dt')
        else:
            print("diffential equation: "+'du/dt=a*a*d(du/dt)/dt'+match[0])
          
    doc=nlp(text)
    for ent in doc.ents:
        #print(ent.text,ent.label_)
        if ent.label_=='boundary_condition':
            print("boundary condition: "+ent.text)

        if ent.label_=='initial_condition':    
            print("initial condition: "+ent.text)
        else:
            print("no initial condition found")
#model evaluation#
def evalu(examples,ner_model):
    scorer=Scorer()
    for input_,annot in examples:
        doc_gold_text=ner_model.make_doc(input_)
        gold=GoldParse(doc_gold_text,entities=annot['entities'])
        pred_value=ner_model(input_)
        scorer.score(pred_value,gold)
    return scorer.scores
print(evalu(test,nlp2))
\end{lstlisting}